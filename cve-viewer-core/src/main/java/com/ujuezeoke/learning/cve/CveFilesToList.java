package com.ujuezeoke.learning.cve;

import com.ujuezeoke.learning.cve.documenthelpers.DocumentFromResource;
import com.ujuezeoke.learning.cve.documenthelpers.VulnerabilityFromDocument;
import com.ujuezeoke.learning.cve.documenthelpers.parser.CveVulnerabilityHandler;
import com.ujuezeoke.learning.cve.model.CveVulnerability;
import org.xml.sax.SAXException;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.parsers.SAXParser;
import javax.xml.parsers.SAXParserFactory;
import java.io.File;
import java.io.IOException;
import java.util.Collections;
import java.util.List;
import java.util.function.Predicate;
import java.util.logging.Level;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static com.ujuezeoke.learning.Loggers.coreLogger;

/**
 * Created by ujuezeoke on 08/06/2016.
 */
public class CveFilesToList {

    private final File cveDirectory;
    private final SAXParserFactory saxParserFactory;

    public CveFilesToList(File cveDirectory) {
        this.cveDirectory = cveDirectory;
        this.saxParserFactory = SAXParserFactory.newInstance();
    }

    public List<CveVulnerability> getCveVulnerabilitiesMatching(Predicate<CveVulnerability> predicate) {
        File[] files = cveDirectory.listFiles();
        if (cveDirectory.exists() && cveDirectory.isDirectory() && files != null) {
            return Stream.of(files)
                    .flatMap(this::toCveVulnerability)
                    .filter(predicate)
                    .collect(Collectors.toList());

        }

        throw new UnsupportedOperationException("Not Yet Implemented");
    }

    private Stream<CveVulnerability> toCveVulnerability(File file) {
        try {
            final SAXParser saxParser = saxParserFactory.newSAXParser();
            final CveVulnerabilityHandler dh = new CveVulnerabilityHandler();
            saxParser.parse(file, dh);

            return dh.getCveVulnerabilities().stream();
        } catch (ParserConfigurationException | SAXException | IOException e) {
            coreLogger().log(Level.WARNING, "Could not parse Document", e);
            return Stream.empty();
        }
    }
}
