package com.ujuezeoke.learning.cve.store;

import com.mongodb.Block;
import com.mongodb.MongoClient;
import com.mongodb.MongoClientOptions;
import com.mongodb.ServerAddress;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoCursor;
import com.mongodb.client.MongoDatabase;
import com.ujuezeoke.learning.cve.model.CveVulnerability;
import com.ujuezeoke.learning.cve.store.codecs.CveVulnerabilityTitleCodec;
import com.ujuezeoke.learning.cve.store.codecs.providers.CveVulnerabilityCodecProvider;
import org.bson.codecs.configuration.CodecRegistries;
import org.bson.codecs.configuration.CodecRegistry;

import java.net.InetSocketAddress;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * Created by ujuezeoke on 15/02/2016.
 */
public class MongoDbVulunerabilityStore implements VulunerabilityStore {

    public static final String CVE_VULNERBILITIES_COLLECTION = "cvevulnerbilities";
    public static final Logger LOGGER = Logger.getLogger(MongoDbVulunerabilityStore.class.getName());
    private final MongoDatabase cve_database;

    public MongoDbVulunerabilityStore(String databaseName, String hostname, Integer port) {
        MongoClient mongoClient = mongodbClientConfiguratiion(hostname, port);
        mongoClient.listDatabaseNames().forEach((Block<String>) blockString -> {
            System.out.println("blockString = " + blockString);
        });
        cve_database = mongoClient.getDatabase(databaseName);
    }

    private MongoClient mongodbClientConfiguratiion(String hostname, Integer port) {
        CodecRegistry codecRegistry = CodecRegistries.fromRegistries(
                CodecRegistries.fromProviders(
                        new CveVulnerabilityCodecProvider()
                ),
                CodecRegistries.fromCodecs(new CveVulnerabilityTitleCodec()),
                MongoClient.getDefaultCodecRegistry()
        );


        MongoClientOptions options = MongoClientOptions.builder()
                .codecRegistry(codecRegistry).build();

        return new MongoClient(new ServerAddress(new InetSocketAddress(hostname, port)), options);
    }

    @Override
    public void store(CveVulnerability cveVulnerability) {
        LOGGER.info("Storing CVE Vulnerability with title " + cveVulnerability.getTitle().getValue());
        MongoCollection<CveVulnerability> cve_databaseCollection = cve_database.getCollection(CVE_VULNERBILITIES_COLLECTION, CveVulnerability.class);

        if (!retriveVulunerabilitiesWithPredicate(cve -> cve.getTitle().equals(cveVulnerability.getTitle())).isEmpty()) {
            updateRecord(cveVulnerability, cve_databaseCollection);
        } else {
            cve_databaseCollection.insertOne(cveVulnerability);
        }
    }

    private void updateRecord(final CveVulnerability cveVulnerability, MongoCollection<CveVulnerability> cve_databaseCollection) {
        LOGGER.info("Nothing to update");
    }

    @Override
    public List<CveVulnerability> retriveVulunerabilitiesWithPredicate(Predicate<CveVulnerability> predicate) {
        LOGGER.info("Retrieving CVE with predicate " + predicate);
        ArrayList<CveVulnerability> objects = new ArrayList<>();
        MongoCursor<CveVulnerability> cveVulnerabilities = cve_database.getCollection(CVE_VULNERBILITIES_COLLECTION,
                CveVulnerability.class)
                .find()
                .iterator();

        cveVulnerabilities.forEachRemaining(objects::add);

        return objects.parallelStream()
                .filter(predicate)
                .collect(Collectors.toList());

    }

}
